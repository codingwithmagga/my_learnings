<html>
  <head>
    <style>
      .Portal {
        border-color: lightblue;
        border-style: solid;
      }
    </style>
  </head>
  <body>
    <h1>
      Software Architecture Patterns and Styles
    </h1>
    <br/>
    <ul>
        <li>Introduction
            <ul>
                <li>What are software architectural patterns?→These are general, repeatable solutions to commonly occurring system design problems. This involves, in general, multiple components that run as separate units.</li>
                <li></li>
                <li>Why use software architectural patterns?
                    <ul>
                        <li>Save valuable time and resources</li>
                        <li>Avoid the risk to make our architecture resemble a Big Ball of Mud (anti-Pattern, no structure, tightly coupled system, ...)</li>
                        <li>Other engineers/architects can follow the pattern</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Multi-Tier Architecture
            <ul>
                <li>Describe what is a multi-tier architecture→A multi-tier architecture is a system which is separated into multiple logical (limiting the scope) and physical distinct tiers. The physical separation allows each tier to be separately developed, upgraded and scaled. </li>
                <li>What is the difference to a multi layer architecture?→Multi-tier architecture distributes application components across multiple physical tiers, while multi-layer architecture separates components into logical layers within a single tier.</li>
                <li>Name restrictions, which allow this architecture to be loosely coupled
                    <ul>
                        <li>Usage of client-server model</li>
                        <li>It is not allowed to skip tiers, they must call each other in a specific order.</li>
                    </ul>
                </li>
                <li></li>
                <li>The three-tier architecture is the most common and popular architectural pattern for client-server, web-based services.
                    <ul>
                        <li>Describe
                            <ul>
                                <li>A three-tier architecture separates an application into presentation, application, and data tiers for improved organization and scalability.</li>
                                <li>Presentation tier: Displays information, takes user input, no business logic</li>
                                <li>Application tier: Contains business logic and processes user requests, communicates with the data tier. Sometimes also called business or logic tier.</li>
                                <li>Data tier: Manages data storage, retrieval, and manipulation, ensuring data (user and business) integrity and security.</li>
                            </ul>
                        </li>
                        <li>Advantages
                            <ul>
                                <li>Easy to scale horizontally</li>
                                <li>Easy to maintain, the logic is concentrated in the application tier</li>
                            </ul>
                        </li>
                        <li>Drawback→Monolithic structure of the logic tier. Business concentrated in a single codebase. Possible high CPU and memory consumption and low development policy.</li>
                    </ul>
                </li>
                <li></li>
                <li>Two tier architecture
                    <ul>
                        <li>Describe→One tier for presentation and business tier, for example desktop applications. One tier for data and storage, often remotely.</li>
                        <li>Advantages
                            <ul>
                                <li>Eliminates overhead of the logic tier in the three tier architecture</li>
                                <li>Faster, more native experience for the user</li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li></li>
                <li>There is also a four and five (not often used) tier architecture.</li>
            </ul>
        </li>
        <li>Microservice Architecture
            <ul>
                <li>Describe→Microservice architecture organizes our business logic as a collection of loosely coupled and independently deployed services. Each service is owned by a small team and has a narrow scope of responsibility. </li>
                <li></li>
                <li>Advantages
                    <ul>
                        <li>Small codebase ⇒ faster and easier development, test, and deployment</li>
                        <li>Better performance and horizontal scalability</li>
                        <li>Better organizational scalability</li>
                        <li>Better security (fault isolation)</li>
                    </ul>
                </li>
                <li></li>
                <li>Drawbacks
                    <ul>
                        <li>All the advantages don&#39;t come out-of-the-box by switching from a monolithic (tier) architecture to a microservice architecture. </li>
                        <li>Overhead </li>
                        <li>Additional challenges (for example, each change should only happen in one service)</li>
                    </ul>
                </li>
                <li></li>
                <li>Name important best practices
                    <ul>
                        <li>Single Responsibility Principle (SRP)</li>
                        <li>Separate Database per service</li>
                    </ul>
                </li>
            </ul>
        </li>
        <li>Event-Driven Architecture
            <ul>
                <li>Instead of direct messages that issues command or requests that ask for data in an event-driven architecture, we have only {{852148871429976::events}}.</li>
                <li></li>
                <li>What is an event?→An event is an immutable statement of a fact or a change.</li>
                <li></li>
                <li>Which components do we have?
                    <ul>
                        <li>Event producers</li>
                        <li>Event consumers</li>
                        <li>Message brokers</li>
                    </ul>
                </li>
                <li></li>
                <li>What benefits do we get?
                    <ul>
                        <li>Decoupled components</li>
                        <li>Asynchronous messages</li>
                        <li>Scalability and flexibility (more services can be added without any changes)</li>
                        <li>Real-time stream analysis (Data analysis, Pattern detection, act upon data in real-time)</li>
                    </ul>
                </li>
                <li></li>
                <li>Describe the event sourcing pattern→Event sourcing is an architectural pattern where state changes are stored as a sequence of events, enabling reconstruction of past states and facilitating auditing and replayability.</li>
                <li></li>
                <li>CQRS pattern
                    <ul>
                        <li>Stands for→Command Query Responsibility Segregation.</li>
                        <li>Which problems does it solve?
                            <ul>
                                <li>Optimizing a database with high load of Read and Update operations (concurrent operations)
                                    <ul>
                                        <li>One database optimized for write, one for read</li>
                                        <li>Events from Database A to B to update the data</li>
                                    </ul>
                                </li>
                                <li>Joining multiple tables located in separate databases that belong to different microservices
                                    <ul>
                                        <li>Changes in two databases of service A and B were sent as event which is taken from service C.</li>
                                        <li>Joins the data and provides a read-only &quot;materialized view&quot;.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li></li>
            </ul>
        </li>

    </ul>
    </body>
</html>
