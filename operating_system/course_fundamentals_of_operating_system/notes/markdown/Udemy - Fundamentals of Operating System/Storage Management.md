- Persistent storage
    - HDD
        - Parts
            - What does it consist of?→Platters, read/write heads, and a spindle motor.
            - Track::A concentric circular path where data is stored and accessed.
            - Geometrical sector::A portion of the disk (a closed region bounded by a circle) enclosed by two radii and an arc.
            - Disc sector::It refers to the intersection of a track and geometrical sector. Minimum storage unit of a hard drive.
            - Cluster::Unit of storage on a hard disk drive (HDD) that consists of a group of contiguous sectors used to improve data access efficiency. It is the smallest logical amount of disk space that can be allocated to hold a file
            - ![](https://remnote-user-data.s3.amazonaws.com/BXJd0YxQT7bImC0iW4mIMWs0tSCU1qrkN4x4RUO4p2ieOwOSM6ZVKWslXEYJycYlzpqpL78yrJlK_V6YStfz9PPoAK8FiuBza2vYtJgX0mYSzbkO9REe2ErQbOgQ96Sx.png)
        - How is data read from the disc >>>
            - New: LBA, Old: Using the CHS method: Cylinder(Track)/Head/Sector
            - Position the read/write head over the cylinder/track 
            - Spin to the correct geometrical sector
            - Read the magnetic data
            - ![](https://remnote-user-data.s3.amazonaws.com/fuY3V0n7BhTSA8vaLtUdrehkuP6Kh_UuRrQkGlHaz0WaiCQZGMdNFWnWYErmjmGkSd0iqspqk_hqhzcIB9xH9rPf58kVjQ_VY4Cn5k2yMp4U3llXFNxnYoktqIbI-qKS.png)
        - Why was introducing new HDD layouts a hard and painful task and how was it solved?→In the early stages, where was no HDD controller and the OS was sending commands directly to the hard drive. The layout of the HDD (CHS) was exposed to the OS. The OS didn't work on other layouts. It was solved by adding an HDD controller which does the conversion from CHS to the new layout.
        - LBA
            - Define→Logical Block Addressing is a method of addressing data on a hard disk drive. Only one number is used to address data, and each linear base address describes a single block. Also used in SSD. Also known as logical sector size.
            - What problem does it solve?→Logical Block Addressing (LBA) solves the problem of needing a consistent way to address data on a hard disk drive (HDD) regardless of its physical layout.
            - Drawback?→Additional cost for the translation of the LBA number to the disk address, which is done by the disk controller.
    - 
    - SSD
        - Structure→SSDs use flash memory organized in blocks and pages for persistent storage. A block is a collection of pages which have a fixed size (4kb, 16kb, ...)
        - What is flash memory?→Non-volatile memory that can be electrically erased and reprogrammed. There is NOR flash and NAND flash. SSD uses NAND flash.
        - Minimum read, write and erase size?→The minimum read and write size is a page. Erase is a whole block because it is expensive.
        - Flash translation layer::Software layer that manages the mapping of logical block addresses to physical storage locations in flash memory devices.
        - Why is LBA mapping more expensive than in HDD→More complex mapping since it has to be updated continuously because there is no "update" functionality in an SSD. The mapping table is stored in a RAM (mostly DRAM) belonging to the SSD.
        - What is Write amplification?→Write amplification is the phenomenon where writing data to a storage device requires writing a larger amount of data than the original data size. Because flash memory must be erased before it can be rewritten, the process to perform a write operation results in moving (or rewriting) user data and metadata more than once.
        - Wear leveling
            - Explain→Wear leveling is a technique used in SSDs to distribute write operations evenly across all memory blocks, extending the lifespan of the drive. Because NAND cells have a write limit.
            - Why is it necessary?→Extending the lifespan. Without this, there are pages which are never touched (like OS files or shared libraries) called cold pages and hot pages which are updated all the time. So some pages will die way before others.
    - 
- File Systems
    - File System are an abstraction above present storage for the users. Writing and reading to a file translates to blocks, and at least one block (one or more LBAs) needs to be allocated.
    - Linux treats everything as a file.
    - 
    - Examples for File Systems >>>
        - FAT (FAT16, FAT32)
        - NTFS (new technology file system)
        - APFS (Apple File System)
        - EXT4 (linux default)
        - XFS
        - btrfs
        - 
    - 
    - PBA
        - Define→A PBA is a Physical Block Address, the actual location of a data block on a storage device. Size is a multiple of an LBA (so one or more). Also known as physical sector size.
    - File system block size
        - Define→The minimum read/write used by the filesystem. Size is a multiple of an LBA (so one or more). When formatting a file system, the user can specify a file system block size, especially on Linux with some restrictions.
    - 
    - FAT32 (File Allocation Table) 
        - Describe >>>
            - FAT32 is a file system that organizes files and directories on a storage device using a File Allocation Table.  
            - The basic idea is an array of 32bit integers, where the index is the LBA. The value in the array itself at this index is the next index until we reach the end.
            - Reading all the LBAs in order gives the file.
            - ![](https://remnote-user-data.s3.amazonaws.com/5PogkNB__koqruzjrDQfee2ysMP1pC2Thro6RRQdPuwp5D593WcuPZXxwRX9iXiHavHEU7vYHhU0OHPoxfrJlw7MGXb19zxV6p_Cc0Gtvh3x-5LPqvdJNBTTxE0DWK4y.png)
        - Why can only be 28 bits used for the LBA index instead of 32?→Four bits are reserved for other purposes like "dirty" or "free", leaving only 28 bits for the LBA index.
        - Explain the issue with low LBA sizes and how it was solved?→In the old standard (LBA=512 byte), you could only address 2^28*512 bytes ~ 128GB. It was solved using Clustering.
        - Clustering
            - Explain→Cluster is a logical grouping of LBAs. For example, 8LBAS = 1 cluster (4kb, if LBA = 512byte). So Block/Cluster 0 ⇒ LBAs 0-7, Block/Cluster 1 ⇒LBAs 8-15 and so on. Now you can address 8*128GB ~ 1 TB.
            - A larger cluster size allows more disk space to be addressed. But what is the disadvantage here?→Larger [Cluster](Storage%20Management/Persistent%20storage/HDD/Parts/Cluster.md) sizes lead to wasted space for smaller files ([Internal fragmentation](../Udemy%20-%20Fundamentals%20of%20Operating%20System/Memory%20Management/Virtual%20memory/Internal%20fragmentation.md)).
    - 
    - OS Page Cache
        - Describe→A region of RAM used by the OS to cache recently accessed file system blocks, improving I/O performance. 
        - What happens when a user writes a file?→The OS writes to the page cache, and then asynchronously writes it to the disk. Calling `fsync()` immediately flushes the page cache to disk. 
    - 
    - File Modes
        - A file must be opened to be used
        - There are different modes in open >>>
            - O_APPEND - append mode
            - O_DIRECT - skips page cache
            - O_SYNC - write always flushes cache (slow, calls fsync() every time, should not be used unless you know what you are doing)
    - 
    - Partitions
        - Explain→Partitions are divisions of a hard drive that allow for the organization and management of files and operating systems. Start and end in an LBA. Each partition can have its own file system and each file system a different block size (cluster). An OS concept, disk and filesystem have no idea of a partition.
        - Partitions should be aligned with the PBAs; otherwise there are performance issues, due to overlapping.
- What really happens in a file IO?
    - API
        - What API is used for reading/writing files in Unix/Linux→Portable Operating System Interface (POSIX) provides functions like `open()`, `read()`, `write()`, and `close()` for file I/O in Unix-like systems. Since everything on Linux is treated as a file, the same API can be used to read/write a socket connection.
        - What API is used for reading/writing files on Windows?→WIN32 API functions.
    - 
